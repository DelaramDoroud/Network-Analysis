# -*- coding: utf-8 -*-
"""assignment 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VXxpuEOVqpWIBTcwfOQovLgJ4FvbnPfU
"""

#from google.colab import files
#uploaded = files.upload()

from heapq import nsmallest
from networkx import shortest_path_length

import networkx as nx
import matplotlib.pyplot as plt
import random
import numpy as np

G = nx.barabasi_albert_graph(n=1000, m=3)
#G.undirected = G.to_undirected()
myGraph = nx.read_edgelist("email-Eu-core.txt", create_using=nx.DiGraph())
myGraph_undirected = myGraph.to_undirected()
myGraph_undirected.remove_edges_from(nx.selfloop_edges(myGraph_undirected))
myGraph_undirected.remove_nodes_from(list(nx.isolates(myGraph_undirected)))

steps = 20


def get_giant_size(G,):
    if len(G) == 0:
        return 0
    return len(max(nx.connected_components(G), key=len))

def get_largest_component_subgraph(G):
    if len(G) == 0:
        return G
    largest_cc = max(nx.connected_components(G), key=len)
    return G.subgraph(largest_cc).copy()
def attacks_on_graph(G,removal_per_step,original_size, x_title):
  results = {
    "Random Attack": [],
    "Target Attack": [],
    "Betweenness Attack": [],
    "Closeness Attack": [],
    "PageRank Attack": [],
  }
  x_values = [(i + 1) * removal_per_step / original_size for i in range(steps)]
  network_sizes = []
  # RANDOM ATTACK
  G_random = G.copy()
  nodes_random = list(G_random.nodes())
  for i in range(steps):
      if len(nodes_random) < removal_per_step:
          results["Random Attack"].append(0)
          break
      to_remove = random.sample(nodes_random, removal_per_step)
      G_random.remove_nodes_from(to_remove)
      G_random = get_largest_component_subgraph(G_random)
      nodes_random = list(G_random.nodes())
      results["Random Attack"].append(get_giant_size(G_random))
      network_sizes.append(G_random.number_of_nodes())

  # DEGREE ATTACK
  G_degree = G.copy()
  for i in range(steps):
      G_degree = get_largest_component_subgraph(G_degree)
      if G_degree.number_of_nodes() == 0:
         results["Target Attack"].append(0)
         continue
      degrees = dict(G_degree.degree())
      sorted_nodes = sorted(degrees, key=degrees.get, reverse=True)
      to_remove = sorted_nodes[:removal_per_step]
      G_degree.remove_nodes_from(to_remove)
      results["Target Attack"].append(get_giant_size(G_degree))

  # BETWEENNESS ATTACK
  G_between = G.copy()
  for i in range(steps):
      G_between = get_largest_component_subgraph(G_between)
      if G_between.number_of_nodes() == 0:
          results["Betweenness Attack"].append(0)
          continue
      betweenness = nx.betweenness_centrality(G_between)
      sorted_nodes = sorted(betweenness, key=betweenness.get, reverse=True)
      to_remove = sorted_nodes[:removal_per_step]
      G_between.remove_nodes_from(to_remove)
      results["Betweenness Attack"].append(get_giant_size(G_between))

  # CLOSENESS ATTACK
  G_close = G.copy()
  for i in range(steps):
      G_close = get_largest_component_subgraph(G_close)
      if G_close.number_of_nodes() == 0:
          results["Closeness Attack"].append(0)
          continue
      closeness = nx.closeness_centrality(G_close)
      sorted_nodes = sorted(closeness, key=closeness.get, reverse=True)
      to_remove = sorted_nodes[:removal_per_step]
      G_close.remove_nodes_from(to_remove)
      results["Closeness Attack"].append(get_giant_size(G_close))

  # PAGERANK ATTACK
  G_pagerank = G.copy()
  for i in range(steps):
      G_pagerank = get_largest_component_subgraph(G_pagerank)
      if G_pagerank.number_of_nodes() == 0:
          results["PageRank Attack"].append(0)
          continue
      pagerank = nx.pagerank(G_pagerank)
      sorted_nodes = sorted(pagerank, key=pagerank.get, reverse=True)
      to_remove = sorted_nodes[:removal_per_step]
      G_pagerank.remove_nodes_from(to_remove)
      results["PageRank Attack"].append(get_giant_size(G_pagerank))

  plt.figure(figsize=(10, 6))
  for attack_type, sizes in results.items():
        plt.plot(x_values[:len(sizes)], sizes, label=attack_type)
        for i, size in enumerate(sizes):
          if size == 0:
              removed_nodes = (i + 1) * removal_per_step
              percentage = (removed_nodes / original_size) * 100
              print("{:<20} {:<30} {:<20.1f}".format(attack_type, removed_nodes, percentage))
              break

  #plt.plot(x_values[:len(network_sizes)], network_sizes, 'o--', color='cyan', label="network size")

  plt.plot()
  plt.xlabel("Fraction of Nodes Removed")
  plt.ylabel("Size of Giant Component")
  plt.title(f"Robustness Under Different Attack Strategies {x_title}")
  plt.grid(True)
  plt.legend()
  plt.tight_layout()
  plt.savefig(f"Robustness Under Different Attack Strategies {x_title}.png")
  plt.show()

original_nodes_sample = list(G.nodes())
original_size_sample = len(original_nodes_sample)
removal_per_step_sample = original_size_sample // steps
attacks_on_graph(G,removal_per_step_sample,original_size_sample,'(Barabási–Albert Graph)')

original_nodes_myGraph = list(myGraph_undirected.nodes())
original_size_myGraph = len(original_nodes_myGraph)
removal_per_step_myGraph = original_size_myGraph // steps
attacks_on_graph(myGraph_undirected,removal_per_step_myGraph,original_size_myGraph,'(email-Eu-core)')

# Function to compute robustness threshold f_c
def compute_fc(G):
    degrees = [deg for _, deg in G.degree()]
    k_avg = np.mean(degrees)
    k2_avg = np.mean([k**2 for k in degrees])
    fc = 1 - 1 / ((k2_avg / k_avg) - 1)
    return round(fc, 5)

# Function to create triangle (ring) connections between neighbors of top-k high-degree nodes
def add_triangle_among_hub_neighbors(G, k=3):
    G_new = G.copy()
    degrees = dict(G.degree())
    hubs = sorted(degrees, key=degrees.get, reverse=True)[:k]

    for hub in hubs:
        neighbors = list(G_new.neighbors(hub))
        for i in range(len(neighbors)):
            for j in range(i + 1, len(neighbors)):
                u, v = neighbors[i], neighbors[j]
                if not G_new.has_edge(u, v) and u != v:
                    G_new.add_edge(u, v)
    return G_new

# Strategy: Add edges between low-degree nodes
def reinforce_low_degree(G, k=200):
    G_new = G.copy()
    degree_dict = dict(G.degree())
    closeness_dict = nx.closeness_centrality(G)

    median_deg = np.median(list(degree_dict.values()))
    low_degree_nodes = [node for node, deg in degree_dict.items() if deg <= median_deg]

    sorted_by_closeness = sorted(closeness_dict.items(), key=lambda x: x[1], reverse=True)
    high_closeness_nodes = [node for node, _ in sorted_by_closeness]

    added = 0
    for u in low_degree_nodes:
        for v in high_closeness_nodes:
            if u != v and not G_new.has_edge(u, v) and not G_new.has_edge(v, u):
                G_new.add_edge(u, v)
                added += 1
                break
        if added >= k:
            break

    return G_new

# Strategy: Add edges between high-closeness nodes
# def connect_neighbors_of_high_closeness(G, k=2):
#     G_new = G.copy()
#     closeness = nx.closeness_centrality(G)
#     top_nodes = sorted(closeness, key=closeness.get, reverse=True)[:k]

#     for node in top_nodes:
#         neighbors = list(G_new.neighbors(node))
#         for i in range(len(neighbors)):
#             for j in range(i+1, len(neighbors)):
#                 u, v = neighbors[i], neighbors[j]
#                 if u != v and not G_new.has_edge(u, v) and not G_new.has_edge(v, u):
#                     G_new.add_edge(u, v)
    return G_new

# Strategy: Add edges between high-betweenness nodes
def connect_neighbors_of_high_betweenness(G, k=2):
    G_new = G.copy()
    betweenness = nx.betweenness_centrality(G)
    top_nodes = sorted(betweenness, key=betweenness.get, reverse=True)[:k]

    for node in top_nodes:
        neighbors = list(G_new.neighbors(node))
        for i in range(len(neighbors)):
            for j in range(i+1, len(neighbors)):
                u, v = neighbors[i], neighbors[j]
                if u != v and not G_new.has_edge(u, v) and not G_new.has_edge(v, u):
                    G_new.add_edge(u, v)
    return G_new

# Strategy: Add edges between low-degree nodes with long distances
def add_min_degree_long_distance(G, num_edges=5):
    G_new = G.copy()
    deg = dict(G_new.degree())
    low = nsmallest(num_edges * 2, deg, key=lambda n: deg[n])
    pairs = []
    for i in range(len(low)):
        for j in range(i+1, len(low)):
            u, v = low[i], low[j]
            if not G_new.has_edge(u, v):
                d = shortest_path_length(G_new, u, v)
                pairs.append((d, u, v))
    for _, u, v in sorted(pairs, reverse=True)[:num_edges]:
        G_new.add_edge(u, v)
    return G_new

def compute_stats(G):
    degrees = [deg for _, deg in G.degree()]
    k_avg = np.mean(degrees)
    k2_avg = np.mean([k**2 for k in degrees])
    fc = 1 - 1 / ((k2_avg / k_avg) - 1)
    return {
        "N": G.number_of_nodes(),
        "L": G.number_of_edges(),
        "⟨k⟩": round(k_avg, 2),
        "⟨k²⟩": round(k2_avg, 2),
        "fc": round(fc, 5)
    }

# myGraph_undirected = myGraph_undirected.subgraph(max(nx.connected_components(myGraph_undirected), key=len)).copy()
# Calculate f_c before and after applying strategy
results = []
graphs = []
strategies = {
    "Original": lambda g: g,
    "hubs": add_triangle_among_hub_neighbors,
    "Low-Degree": reinforce_low_degree,
    "High-Betweenness": connect_neighbors_of_high_betweenness,
    "low_degree_long_distance": add_min_degree_long_distance,
    #"high_closeness" : connect_neighbors_of_high_closeness
}
for name, func in strategies.items():
    G_temp = myGraph_undirected.subgraph(max(nx.connected_components(myGraph_undirected), key=len)).copy()
    for step in range(4):
        stats = compute_stats(G_temp)
        stats["Strategy"] = name
        stats["Step"] = step
        results.append(stats)
        graphs.append(G_temp)
        if step < 3:
            G_temp = func(G_temp)

for val in results:
  for k in val:
    print(f"{k}: {val[k]}")
  print()

def draw_graph(G, title):
    plt.figure(figsize=(8, 6))
    pos = nx.spring_layout(G, seed=42)
    nx.draw_networkx_nodes(G, pos, node_size=20, node_color="skyblue")
    nx.draw_networkx_edges(G, pos, alpha=0.4)
    plt.title(title)
    plt.axis("off")
    plt.tight_layout()
    plt.savefig(f"{title}.png")
    plt.show()

print(len(graphs))
draw_graph(graphs[0], f"Original Email-Eu-core Graph")
draw_graph(graphs[1], f"Ring enhancement ")
draw_graph(graphs[5], f"Bridge enhancement between high-betweenness nodes ")
#draw_graph(graphs[3], f"Bridge enhancement between low-degree nodes ")
#draw_graph(graphs[12], f"Bridge enhancement between low-degree nodes with long distances ")

original_nodes_myGraph = list(graphs[7].nodes())
original_size_myGraph = len(original_nodes_myGraph)
removal_per_step_myGraph = original_size_myGraph // steps
attacks_on_graph(graphs[5],removal_per_step_myGraph,original_size_myGraph,'(email-Eu-core)')