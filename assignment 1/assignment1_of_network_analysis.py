# -*- coding: utf-8 -*-
"""assignment1 of Network Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZOCJYQU8ofctY7g3vKzYYcajgY6SeO2J
"""

#from google.colab import files

#uploaded = files.upload()

import networkx as nx
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import collections
import itertools
import igraph as ig
import leidenalg
from sklearn.metrics import normalized_mutual_info_score, adjusted_rand_score
from networkx.algorithms.community import louvain_communities
import community
import time

myGraph = nx.read_edgelist("email-Eu-core.txt", create_using=nx.DiGraph())
# myGraph.remove_edges_from(nx.selfloop_edges(myGraph))
# myGraph.remove_nodes_from(list(nx.isolates(myGraph)))

in_degrees = dict(myGraph.in_degree())
avg_in_degree = sum(in_degrees.values()) / len(in_degrees)

out_degrees = dict(myGraph.out_degree())
avg_out_degree = sum(out_degrees.values()) / len(out_degrees)

print(f"[Cleaned Graph] Average in-degree: {avg_in_degree:.2f}")
print(f"[Cleaned Graph] Average out-degree: {avg_out_degree:.2f}")

myGraph_undirected = myGraph.to_undirected()

plt.figure(figsize=(10, 8))
pos = nx.spring_layout(myGraph_undirected, seed=42)
nx.draw(myGraph_undirected, pos, with_labels=False, node_size=20, node_color='skyblue', edge_color='gray', alpha=0.5)
plt.title("Original Graph Before Cleaning")
plt.axis('off')
plt.tight_layout()
#plt.savefig("original_graph_before_cleaning.png", dpi=300)
plt.show()

#cleaning dataset
myGraph_undirected.remove_edges_from(nx.selfloop_edges(myGraph_undirected))
myGraph_undirected.remove_nodes_from(list(nx.isolates(myGraph_undirected)))

largest_cc = max(nx.connected_components(myGraph_undirected), key=len)
graph_sub=(myGraph_undirected.subgraph(largest_cc))

num_nodes_before = myGraph.number_of_nodes()
num_nodes_after = myGraph_undirected.number_of_nodes()
num_edges_before = myGraph.number_of_edges()
num_edges_after = myGraph_undirected.number_of_edges()
density = nx.density(myGraph_undirected)
diameter = nx.diameter(myGraph_undirected)
avg_clustering = nx.average_clustering(myGraph_undirected)
assortativity = nx.degree_assortativity_coefficient(myGraph_undirected)
print(f"number of nodes -> before cleaning: {num_nodes_before} - after cleaning : {num_nodes_after}")
print(f"Number of edges -> before cleaning: {num_edges_before} - after cleaning : {num_edges_after}")
print(density, diameter, avg_clustering, assortativity)

degrees = dict(myGraph_undirected.degree())
avg_degree = sum(degrees.values()) / len(degrees)
print(f"Average degree: {avg_degree:.2f}")

degrees = [d for _, d in myGraph_undirected.degree()]
#print(degrees)
plt.figure(figsize=(8, 5))
plt.hist(degrees, bins=50, color='skyblue', edgecolor='black')
plt.title("Degree Distribution of Email-Eu-core")
plt.xlabel("Degree")
plt.ylabel("Number of Nodes")
plt.grid(True)
plt.tight_layout()
plt.savefig("degree_distribution.png")
plt.show()

degrees = [d for _, d in myGraph_undirected.degree()]
max_degree = max(degrees)

hist, bin_edges = np.histogram(degrees, bins=range(max_degree + 2), density=True)

plt.figure(figsize=(8, 5))
plt.bar(bin_edges[:-1], hist, width=0.8, color='skyblue', edgecolor='skyblue')
plt.xlabel("Degree")
plt.ylabel("Normalized Frequency")
plt.title("Normalized Degree Distribution of Email-Eu-core")
plt.grid(True)
plt.tight_layout()
plt.savefig("normalized_degree_distribution.png")
plt.show()

# Run the Louvain algorithm and log execution time
louvain_start_time  = time.time()
communities_louvain = louvain_communities(myGraph_undirected)
louvain_end_time  = time.time()

# Print number of communities
print(f"Number of communities found: {len(communities_louvain)}")

# Print the nodes in each community and check if connected
for i, community in enumerate(communities_louvain):
    subgraph = myGraph_undirected.subgraph(community)
    print(f"Community {i}: {sorted(community)} - Connected: {nx.is_connected(subgraph)}!")
    print(f"Number of nodes in community {i}: {len(community)}")

print(f"Execution time: {louvain_end_time  - louvain_start_time :.4f} seconds")

#!pip install leidenalg igraph

graph_ig = ig.Graph.TupleList(myGraph_undirected.edges(), directed=False)
leiden_start_time  = time.time()
communities_leiden = leidenalg.find_partition(graph_ig, leidenalg.ModularityVertexPartition)
leiden_end_time  = time.time()
print(f"Number of communities found: {len(communities_leiden)}")

for i, community in enumerate(communities_leiden):
    print(f"Community {i}: {sorted(community)}")
    print(f"Number of nodes in community {i}: {len(community)}")

print(f"Execution time: {leiden_end_time  - leiden_start_time :.4f} seconds")

louvain_labels = [0] * len(myGraph_undirected.nodes())
node_id_to_index = {node: i for i, node in enumerate(sorted(myGraph_undirected.nodes()))}

for label, community in enumerate(communities_louvain):
    for node in community:
        idx = node_id_to_index[str(node)]
        louvain_labels[idx] = label

leiden_labels = [0] * len(myGraph_undirected.nodes())

for label, community in enumerate(communities_leiden):
    for node in community:
        node_str = graph_ig.vs[int(node)]["name"]
        if node_str in node_id_to_index:
            idx = node_id_to_index[node_str]
            leiden_labels[idx] = label

nmi = normalized_mutual_info_score(louvain_labels, leiden_labels)
ari = adjusted_rand_score(louvain_labels, leiden_labels)
print(f"NMI between Louvain and Leiden: {nmi:.4f}")
print(f"ARI between Louvain and Leiden: {ari:.4f}")

# Assign colors to nodes based on Louvain communities
louvain_color_map = {}
for cid, community in enumerate(communities_louvain):
    for node in community:
        louvain_color_map[node] = cid
louvain_colors = [louvain_color_map[node] for node in myGraph_undirected.nodes()]

# Plot Louvain community graph
plt.figure(figsize=(10, 8))
pos = nx.spring_layout(myGraph_undirected, seed=42)
nx.draw_networkx_nodes(myGraph_undirected, pos, node_color=louvain_colors, cmap=plt.cm.tab20, node_size=30)
nx.draw_networkx_edges(myGraph_undirected, pos, alpha=0.2)
plt.title("Communities Detected by Louvain Algorithm")
plt.axis('off')
plt.tight_layout()
plt.savefig("louvain_community_graph.png", dpi=300)
plt.show()

leiden_color_map = {}
for cid, community in enumerate(communities_leiden):
    for node in community:
        node_name = graph_ig.vs[node]["name"]
        leiden_color_map[node_name] = cid
leiden_colors = [leiden_color_map[node] for node in myGraph_undirected.nodes()]

# Plot Leiden community graph
plt.figure(figsize=(10, 8))
nx.draw_networkx_nodes(myGraph_undirected, pos, node_color=leiden_colors, cmap=plt.cm.tab20, node_size=30)
nx.draw_networkx_edges(myGraph_undirected, pos, alpha=0.2)
plt.title("Communities Detected by Leiden Algorithm")
plt.axis('off')
plt.tight_layout()
plt.savefig("leiden_community_graph.png", dpi=300)
plt.show()

algorithms = ['Louvain', 'Leiden']
num_communities = [len(communities_louvain), len(communities_leiden)]
modularities = [
    nx.algorithms.community.modularity(myGraph_undirected, communities_louvain),
    communities_leiden.modularity
]
print(modularities[0], modularities[1])

x = np.arange(len(algorithms))
width = 0.35

fig, ax1 = plt.subplots(figsize=(8, 5))

bars1 = ax1.bar(x - width/2, num_communities, width, label='Number of Communities', color='steelblue')
ax1.set_xlabel('Algorithm')
ax1.set_ylabel('Number of Communities', color='steelblue')
ax1.tick_params(axis='y', labelcolor='steelblue')
ax1.set_xticks(x)
ax1.set_xticklabels(algorithms, rotation=20)
ax1.set_ylim(0, 20)

ax2 = ax1.twinx()
bars2 = ax2.bar(x + width/2, modularities, width, label='Modularity', color='orange')
ax2.set_ylabel('Modularity', color='orange')
ax2.tick_params(axis='y', labelcolor='orange')
ax2.set_ylim(0, 0.5)

plt.title("Community Structure Comparison")
fig.tight_layout()
plt.legend([bars1, bars2], ['Number of Communities', 'Modularity'], loc='upper left')
plt.savefig("community_structure_comparison.png", dpi=300)
plt.show()

louvain_time = louvain_end_time - louvain_start_time
leiden_time = leiden_end_time - leiden_start_time

plt.figure(figsize=(5,4))
plt.bar(['Louvain', 'Leiden'], [louvain_time, leiden_time], color=['skyblue', 'lightcoral'])
plt.title("Execution Time Comparison")
plt.ylabel("Time (seconds)")
plt.tight_layout()
plt.savefig("execution_time_comparison.png", dpi=300)
plt.show()

algorithms = ['Louvain', 'Leiden']
labels_dict = {
    'Louvain': louvain_labels,
    'Leiden': leiden_labels
    }

n = len(algorithms)
nmi_matrix = np.zeros((n, n))
ari_matrix = np.zeros((n, n))

for i in range(n):
    for j in range(n):
        nmi_matrix[i][j] = normalized_mutual_info_score(labels_dict[algorithms[i]], labels_dict[algorithms[j]])
        ari_matrix[i][j] = adjusted_rand_score(labels_dict[algorithms[i]], labels_dict[algorithms[j]])

fig, axs = plt.subplots(1, 2, figsize=(12, 5))

sns.heatmap(nmi_matrix, xticklabels=algorithms, yticklabels=algorithms,
            annot=True, fmt=".3f", cmap='YlGnBu', vmin=0, vmax=1, ax=axs[0])
axs[0].set_title("Normalized Mutual Information (NMI)")

sns.heatmap(ari_matrix, xticklabels=algorithms, yticklabels=algorithms,
            annot=True, fmt=".3f", cmap='YlGnBu', vmin=0, vmax=1, ax=axs[1])
axs[1].set_title("Adjusted Rand Index (ARI)")

plt.tight_layout()
plt.savefig("algorithm_similarity_metrics.png", dpi=300)
plt.show()